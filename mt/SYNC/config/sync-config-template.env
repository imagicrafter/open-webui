# SQLite + Supabase Sync System - Configuration Template
# Phase 1: High Availability Sync Container
#
# USAGE:
# 1. Copy this file to .env in the docker/ directory
# 2. Fill in your Supabase credentials and configuration
# 3. Generate a strong password for sync_service role
# 4. Deploy using deploy-sync-cluster.sh

# ============================================================================
# SUPABASE CONNECTION
# ============================================================================

# Supabase PostgreSQL connection URL (Session Mode - Port 5432)
# Format: postgresql://USER:PASSWORD@REGION.pooler.supabase.com:5432/postgres
DATABASE_URL=postgresql://sync_service:CHANGE_THIS_PASSWORD@aws-1-us-east-2.pooler.supabase.com:5432/postgres

# Supabase Project Details
SUPABASE_PROJECT_REF=your-project-ref
SUPABASE_REGION=aws-1-us-east-2

# Admin URL for initial setup (use postgres user, not sync_service)
# Only used during deployment, not by sync containers
SUPABASE_ADMIN_URL=postgresql://postgres.PROJECT_REF:ADMIN_PASSWORD@REGION.pooler.supabase.com:5432/postgres

# ============================================================================
# CLUSTER CONFIGURATION
# ============================================================================

# Host identification
HOST_NAME=prod-host-1
HOST_IP=159.203.94.143
CLUSTER_NAME=prod-host-1

# Cluster role (primary or secondary)
# This should be set differently for each container via docker-compose
# ROLE=primary  # Set in docker-compose.yml

# ============================================================================
# SYNC SETTINGS
# ============================================================================

# Default sync interval in seconds (300 = 5 minutes)
DEFAULT_SYNC_INTERVAL=300

# Batch size for sync operations (rows per batch)
BATCH_SIZE=1000

# Tables to sync (comma-separated)
SYNC_TABLES=user,auth,tag,config,chat,oauth_session,function,message

# Sync parallelization
MAX_SYNC_WORKERS=4
ENABLE_PARALLEL_SYNC=true

# ============================================================================
# HIGH AVAILABILITY SETTINGS
# ============================================================================

# Leader election lease duration (seconds)
LEASE_DURATION=60

# Heartbeat interval (seconds) - should be less than lease duration
HEARTBEAT_INTERVAL=30

# Leader election retry settings
LEADER_ELECTION_RETRY_INTERVAL=5
LEADER_ELECTION_MAX_RETRIES=3

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

# Cache TTL (seconds) - how long to keep state in local cache
CACHE_TTL=300

# Cache invalidation strategy (eager or lazy)
CACHE_INVALIDATION=eager

# State sync interval (seconds) - how often to sync state with Supabase
STATE_SYNC_INTERVAL=60

# ============================================================================
# MONITORING & OBSERVABILITY
# ============================================================================

# Enable Prometheus metrics
ENABLE_METRICS=true

# Metrics port (exposed via /metrics endpoint)
METRICS_PORT=9443

# API port for primary container
API_PORT=9443

# API port for secondary container
SECONDARY_API_PORT=9444

# Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
LOG_LEVEL=INFO

# Log format (json or text)
LOG_FORMAT=json

# Enable request ID tracking
ENABLE_REQUEST_ID=true

# ============================================================================
# SECURITY
# ============================================================================

# Connection pool settings
DB_POOL_MIN_SIZE=2
DB_POOL_MAX_SIZE=10
DB_POOL_MAX_QUERIES=50000
DB_POOL_MAX_INACTIVE_CONNECTION_LIFETIME=300

# Connection timeout (seconds)
DB_CONNECTION_TIMEOUT=30

# Enable SSL for database connections
DB_SSL_MODE=require

# ============================================================================
# CONFLICT RESOLUTION
# ============================================================================

# Path to conflict resolution configuration
CONFLICT_RESOLUTION_CONFIG=/app/config/conflict-resolution-default.json

# Enable automatic conflict resolution
ENABLE_AUTO_RESOLUTION=true

# Max conflicts to auto-resolve per sync operation
MAX_AUTO_RESOLVE_PER_SYNC=100

# ============================================================================
# ADVANCED OPTIONS
# ============================================================================

# Enable debug mode (verbose logging, additional checks)
DEBUG_MODE=false

# Enable sync dry-run mode (simulate sync without writing)
DRY_RUN=false

# SQLite WAL checkpoint mode (PASSIVE, FULL, RESTART, TRUNCATE)
WAL_CHECKPOINT_MODE=TRUNCATE

# Sync timeout (seconds) - max time for a single sync operation
SYNC_TIMEOUT=600

# Enable sync job queueing
ENABLE_SYNC_QUEUE=true
SYNC_QUEUE_MAX_SIZE=100

# ============================================================================
# DOCKER INTEGRATION
# ============================================================================

# Docker socket path (for executing docker commands)
DOCKER_SOCKET=/var/run/docker.sock

# Docker network (for container-to-container communication)
DOCKER_NETWORK=bridge

# ============================================================================
# HEALTH CHECK
# ============================================================================

# Health check interval (seconds)
HEALTHCHECK_INTERVAL=30

# Health check timeout (seconds)
HEALTHCHECK_TIMEOUT=10

# Health check retries before marking unhealthy
HEALTHCHECK_RETRIES=3

# ============================================================================
# NOTES
# ============================================================================
#
# Security Best Practices:
# 1. Generate strong passwords: openssl rand -base64 32
# 2. Never commit .env files to version control
# 3. Use Docker secrets in production instead of environment variables
# 4. Rotate sync_service password regularly
# 5. Limit sync_service connection count in database
#
# Performance Tuning:
# 1. Increase BATCH_SIZE for larger datasets (test memory usage)
# 2. Adjust CACHE_TTL based on sync frequency
# 3. Tune DB_POOL_MAX_SIZE based on concurrent clients
# 4. Monitor SYNC_TIMEOUT and adjust for slow networks
#
# High Availability:
# 1. LEASE_DURATION should be > 2 * HEARTBEAT_INTERVAL
# 2. Test failover time in staging before production
# 3. Monitor leader_elections_total metric for excessive churn
# 4. Set up alerts for is_leader gauge (should always be 1 in cluster)
#
